// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_UAV_CPCM_H_
#define FLATBUFFERS_GENERATED_UAV_CPCM_H_

#include "flatbuffers/flatbuffers.h"

namespace cpcm {

struct Pos;

struct Gos;

struct Uav;

enum Mode {
  Mode_LightBridge = 0,
  Mode_Mavic = 1,
  Mode_Wifi = 2,
  Mode_MIN = Mode_LightBridge,
  Mode_MAX = Mode_Wifi
};

inline const Mode (&EnumValuesMode())[3] {
  static const Mode values[] = {
    Mode_LightBridge,
    Mode_Mavic,
    Mode_Wifi
  };
  return values;
}

inline const char * const *EnumNamesMode() {
  static const char * const names[] = {
    "LightBridge",
    "Mavic",
    "Wifi",
    nullptr
  };
  return names;
}

inline const char *EnumNameMode(Mode e) {
  if (e < Mode_LightBridge || e > Mode_Wifi) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMode()[index];
}

enum Location {
  Location_NONE = 0,
  Location_Gos = 1,
  Location_Pos = 2,
  Location_MIN = Location_NONE,
  Location_MAX = Location_Pos
};

inline const Location (&EnumValuesLocation())[3] {
  static const Location values[] = {
    Location_NONE,
    Location_Gos,
    Location_Pos
  };
  return values;
}

inline const char * const *EnumNamesLocation() {
  static const char * const names[] = {
    "NONE",
    "Gos",
    "Pos",
    nullptr
  };
  return names;
}

inline const char *EnumNameLocation(Location e) {
  if (e < Location_NONE || e > Location_Pos) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLocation()[index];
}

template<typename T> struct LocationTraits {
  static const Location enum_value = Location_NONE;
};

template<> struct LocationTraits<Gos> {
  static const Location enum_value = Location_Gos;
};

template<> struct LocationTraits<Pos> {
  static const Location enum_value = Location_Pos;
};

bool VerifyLocation(flatbuffers::Verifier &verifier, const void *obj, Location type);
bool VerifyLocationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Pos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float x() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
};

struct PosBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_x(float x) {
    fbb_.AddElement<float>(Pos::VT_X, x, 0.0f);
  }
  void add_y(float y) {
    fbb_.AddElement<float>(Pos::VT_Y, y, 0.0f);
  }
  void add_z(float z) {
    fbb_.AddElement<float>(Pos::VT_Z, z, 0.0f);
  }
  explicit PosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PosBuilder &operator=(const PosBuilder &);
  flatbuffers::Offset<Pos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pos> CreatePos(
    flatbuffers::FlatBufferBuilder &_fbb,
    float x = 0.0f,
    float y = 0.0f,
    float z = 0.0f) {
  PosBuilder builder_(_fbb);
  builder_.add_z(z);
  builder_.add_y(y);
  builder_.add_x(x);
  return builder_.Finish();
}

struct Gos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LONGITUDE = 4,
    VT_LATITUDE = 6,
    VT_ALTITUDE = 8
  };
  float longitude() const {
    return GetField<float>(VT_LONGITUDE, 0.0f);
  }
  float latitude() const {
    return GetField<float>(VT_LATITUDE, 0.0f);
  }
  float altitude() const {
    return GetField<float>(VT_ALTITUDE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LONGITUDE) &&
           VerifyField<float>(verifier, VT_LATITUDE) &&
           VerifyField<float>(verifier, VT_ALTITUDE) &&
           verifier.EndTable();
  }
};

struct GosBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_longitude(float longitude) {
    fbb_.AddElement<float>(Gos::VT_LONGITUDE, longitude, 0.0f);
  }
  void add_latitude(float latitude) {
    fbb_.AddElement<float>(Gos::VT_LATITUDE, latitude, 0.0f);
  }
  void add_altitude(float altitude) {
    fbb_.AddElement<float>(Gos::VT_ALTITUDE, altitude, 0.0f);
  }
  explicit GosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GosBuilder &operator=(const GosBuilder &);
  flatbuffers::Offset<Gos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gos> CreateGos(
    flatbuffers::FlatBufferBuilder &_fbb,
    float longitude = 0.0f,
    float latitude = 0.0f,
    float altitude = 0.0f) {
  GosBuilder builder_(_fbb);
  builder_.add_altitude(altitude);
  builder_.add_latitude(latitude);
  builder_.add_longitude(longitude);
  return builder_.Finish();
}

struct Uav FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LOCATION_TYPE = 4,
    VT_LOCATION = 6,
    VT_MODE = 8,
    VT_PATH = 10,
    VT_FREQ = 12,
    VT_BANDWIDTH = 14
  };
  Location location_type() const {
    return static_cast<Location>(GetField<uint8_t>(VT_LOCATION_TYPE, 0));
  }
  const void *location() const {
    return GetPointer<const void *>(VT_LOCATION);
  }
  template<typename T> const T *location_as() const;
  const Gos *location_as_Gos() const {
    return location_type() == Location_Gos ? static_cast<const Gos *>(location()) : nullptr;
  }
  const Pos *location_as_Pos() const {
    return location_type() == Location_Pos ? static_cast<const Pos *>(location()) : nullptr;
  }
  Mode mode() const {
    return static_cast<Mode>(GetField<int8_t>(VT_MODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pos>> *path() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pos>> *>(VT_PATH);
  }
  double freq() const {
    return GetField<double>(VT_FREQ, 0.0);
  }
  double bandwidth() const {
    return GetField<double>(VT_BANDWIDTH, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LOCATION_TYPE) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           VerifyLocation(verifier, location(), location_type()) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyVector(path()) &&
           verifier.VerifyVectorOfTables(path()) &&
           VerifyField<double>(verifier, VT_FREQ) &&
           VerifyField<double>(verifier, VT_BANDWIDTH) &&
           verifier.EndTable();
  }
};

template<> inline const Gos *Uav::location_as<Gos>() const {
  return location_as_Gos();
}

template<> inline const Pos *Uav::location_as<Pos>() const {
  return location_as_Pos();
}

struct UavBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_location_type(Location location_type) {
    fbb_.AddElement<uint8_t>(Uav::VT_LOCATION_TYPE, static_cast<uint8_t>(location_type), 0);
  }
  void add_location(flatbuffers::Offset<void> location) {
    fbb_.AddOffset(Uav::VT_LOCATION, location);
  }
  void add_mode(Mode mode) {
    fbb_.AddElement<int8_t>(Uav::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pos>>> path) {
    fbb_.AddOffset(Uav::VT_PATH, path);
  }
  void add_freq(double freq) {
    fbb_.AddElement<double>(Uav::VT_FREQ, freq, 0.0);
  }
  void add_bandwidth(double bandwidth) {
    fbb_.AddElement<double>(Uav::VT_BANDWIDTH, bandwidth, 0.0);
  }
  explicit UavBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UavBuilder &operator=(const UavBuilder &);
  flatbuffers::Offset<Uav> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Uav>(end);
    return o;
  }
};

inline flatbuffers::Offset<Uav> CreateUav(
    flatbuffers::FlatBufferBuilder &_fbb,
    Location location_type = Location_NONE,
    flatbuffers::Offset<void> location = 0,
    Mode mode = Mode_LightBridge,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pos>>> path = 0,
    double freq = 0.0,
    double bandwidth = 0.0) {
  UavBuilder builder_(_fbb);
  builder_.add_bandwidth(bandwidth);
  builder_.add_freq(freq);
  builder_.add_path(path);
  builder_.add_location(location);
  builder_.add_mode(mode);
  builder_.add_location_type(location_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Uav> CreateUavDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Location location_type = Location_NONE,
    flatbuffers::Offset<void> location = 0,
    Mode mode = Mode_LightBridge,
    const std::vector<flatbuffers::Offset<Pos>> *path = nullptr,
    double freq = 0.0,
    double bandwidth = 0.0) {
  auto path__ = path ? _fbb.CreateVector<flatbuffers::Offset<Pos>>(*path) : 0;
  return cpcm::CreateUav(
      _fbb,
      location_type,
      location,
      mode,
      path__,
      freq,
      bandwidth);
}

inline bool VerifyLocation(flatbuffers::Verifier &verifier, const void *obj, Location type) {
  switch (type) {
    case Location_NONE: {
      return true;
    }
    case Location_Gos: {
      auto ptr = reinterpret_cast<const Gos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Location_Pos: {
      auto ptr = reinterpret_cast<const Pos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyLocationVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyLocation(
        verifier,  values->Get(i), types->GetEnum<Location>(i))) {
      return false;
    }
  }
  return true;
}

inline const cpcm::Uav *GetUav(const void *buf) {
  return flatbuffers::GetRoot<cpcm::Uav>(buf);
}

inline const cpcm::Uav *GetSizePrefixedUav(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<cpcm::Uav>(buf);
}

inline bool VerifyUavBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<cpcm::Uav>(nullptr);
}

inline bool VerifySizePrefixedUavBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<cpcm::Uav>(nullptr);
}

inline void FinishUavBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cpcm::Uav> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedUavBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<cpcm::Uav> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace cpcm

#endif  // FLATBUFFERS_GENERATED_UAV_CPCM_H_
